<!DOCTYPE html>
<html lang="en" class="yui-overrride">
<head>
    <meta charset="utf-8">
    <title>/home/lhawsa/Documents/projects/openveo/openveo-rest-nodejs-client/lib/RestClient.js - OpenVeo REST NodeJS client API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1 class="blue-main-title">OpenVeo REST NodeJS client API</h1>
        </div>
        <div class="yui3-u-1-4 version project-version">
            API Docs for: 3.1.0
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AuthenticationError.html">AuthenticationError</a></li>
                                <li><a href="../classes/OpenVeoClient.html">OpenVeoClient</a></li>
                                <li><a href="../classes/Request.html">Request</a></li>
                                <li><a href="../classes/RequestError.html">RequestError</a></li>
                                <li><a href="../classes/RestClient.html">RestClient</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/rest-client.html">rest-client</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: /home/lhawsa/Documents/projects/openveo/openveo-rest-nodejs-client/lib/RestClient.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

/**
 * Defines a client to connect to REST web service.
 *
 * @module rest-client
 * @main rest-client
 */

const url = require(&#x27;url&#x27;);
const fs = require(&#x27;fs&#x27;);
const path = require(&#x27;path&#x27;);
const errors = process.requireRestClient(&#x27;lib/errors/index.js&#x27;);
const Request = process.requireRestClient(&#x27;lib/Request.js&#x27;);
const RequestError = errors.RequestError;
const AuthenticationError = errors.AuthenticationError;

/**
 * Rejects all requests with the given error.
 *
 * If the request is running, it will be aborted.
 *
 * @private
 * @param {Set} requests The list of requests to reject
 * @param {Error} error The reject&#x27;s error
 */
function rejectAll(requests, error) {
  for (const request of requests) {
    request.abort();
    request.reject(error);
  }
}

class RestClient {

  /**
   * Creates a client to connect to REST web service.
   *
   * It aims to facilitate implementation of a REST web service client. Requesting an end point, without being
   * authenticated, will automatically execute the *authenticateRequest* first before calling the end point.
   * If token expired, a new authentication is made automatically.
   *
   * You MUST:
   * - Extend this class
   * - Define a *authenticateRequest* property with a Request as a value. This will be automatically called by
   *   the RestClient to get an access token from the server (response from server should contain the property
   *   *access_token* containing the access token which will be stored in RestClient *accessToken* property and used
   *   for all subsequent requests). Use *buildRequest* function to create the authenticate request
   * - Make sure that the web service server returns a property *error_description* set to &quot;Token not found or expired&quot;
   *   if token couln&#x27;t be retrieved
   * - Make sure that the web service server returns a property *error_description* set to &quot;Token already expired&quot;
   *   if token has expired
   *
   * You MAY:
   * - Override function *getAuthenticationHeaders*. By default the list of headers returned by
   *   *getAuthenticationHeaders* function will be added to all requests sent to the server. One of this header may be
   *   the authentication header for example
   *
   * @class RestClient
   * @constructor
   * @param {String} webServiceUrl The complete URL of the REST web service (with protocol and port)
   * @param {String} [certificate] Absolute path to the web service server full chain certificate file
   * @throws {TypeError} Thrown if webServiceUrl is not a valid String
   */
  constructor(webServiceUrl, certificate) {
    if (!webServiceUrl || typeof webServiceUrl !== &#x27;string&#x27;)
      throw new TypeError(&#x60;Invalid web service url : ${webServiceUrl}&#x60;);

    // Parse web service url to get protocol, host and port
    const urlChunks = url.parse(webServiceUrl);
    const protocol = urlChunks.protocol === &#x27;https:&#x27; ? &#x27;https&#x27; : &#x27;http&#x27;;
    const port = parseInt(urlChunks.port) || (protocol === &#x27;http&#x27; ? 80 : 443);

    Object.defineProperties(this, {

      /**
       * Web service protocol, either &quot;http&quot; or &quot;https&quot;.
       *
       * @property protocol
       * @type String
       * @final
       */
      protocol: {value: protocol, enumerable: true},

      /**
       * Web service server host name.
       *
       * @property hostname
       * @type String
       * @final
       */
      hostname: {value: urlChunks.hostname, enumerable: true},

      /**
       * Web service server port.
       *
       * @property port
       * @type Number
       * @final
       */
      port: {value: port, enumerable: true},

      /**
       * Web service URL path.
       *
       * @property path
       * @type String
       * @final
       */
      path: {value: urlChunks.path, enumerable: true},

      /**
       * Application access token provided by the web service.
       *
       * @property accessToken
       * @type String
       */
      accessToken: {value: null, writable: true, enumerable: true},

      /**
       * Path to the web service server certificate file.
       *
       * @property certificate
       * @type String
       * @final
       */
      certificate: {value: certificate, enumerable: true},

      /**
       * The collection of queued requests waiting to be executed.
       *
       * @property queuedRequests
       * @type Set
       */
      queuedRequests: {writable: true, value: new Set(), enumerable: true},

      /**
       * Maximum number of authentication attempts to perform on a request in case of an invalid or expired token.
       *
       * @property maxAuthenticationAttempts
       * @type Number
       * @default 1
       */
      maxAuthenticationAttempts: {value: 1, writable: true, enumerable: true}

    });
  }

  /**
   * Executes a GET request.
   *
   * If client is not authenticated or access token has expired, a new authentication is automatically
   * performed.
   *
   * @async
   * @method get
   * @param {String} endPoint The web service end point to reach with query parameters
   * @param {Object} [options] The list of http(s) options as described by NodeJS http.request documentation
   * @param {Number} [timeout=10000] Maximum execution time for the request (in ms), set it to Infinity for a request
   * without limits
   * @return {Promise} Promise resolving with result as an Object
   * @throws {TypeError} Thrown if endPoint is not valid a String
   */
  get(endPoint, options, timeout) {
    return this.executeRequest(&#x27;get&#x27;, endPoint, options, null, timeout);
  }

  /**
   * Executes a POST request.
   *
   * If client is not authenticated or access token has expired, a new authentication is automatically
   * performed.
   *
   * @async
   * @method post
   * @param {String} endPoint The web service end point to reach with query parameters
   * @param {Object|String} [body] The request body
   * @param {Object} [options] The list of http(s) options as described by NodeJS http.request documentation
   * @param {Number} [timeout=10000] Maximum execution time for the request (in ms), set it to Infinity for a request
   * without limits
   * @param {Boolean} [multiparted=false] true to send body as multipart/form-data
   * @return {Promise} Promise resolving with results as an Object
   * @throws {TypeError} Thrown if endPoint is not valid a String
   */
  post(endPoint, body, options, timeout, multiparted) {
    return this.executeRequest(&#x27;post&#x27;, endPoint, options, body, timeout, multiparted);
  }

  /**
   * Executes a PATCH request.
   *
   * If client is not authenticated or access token has expired, a new authentication is automatically
   * performed.
   *
   * @async
   * @method patch
   * @param {String} endPoint The web service end point to reach with query parameters
   * @param {Object|String} [body] The request body
   * @param {Object} [options] The list of http(s) options as described by NodeJS http.request documentation
   * @param {Number} [timeout=10000] Maximum execution time for the request (in ms), set it to Infinity for a request
   * without limits
   * @param {Boolean} [multiparted=false] true to send body as multipart/form-data
   * @return {Promise} Promise resolving with results as an Object
   * @throws {TypeError} Thrown if endPoint is not valid a String
   */
  patch(endPoint, body, options, timeout, multiparted) {
    return this.executeRequest(&#x27;patch&#x27;, endPoint, options, body, timeout, multiparted);
  }

  /**
   * Executes a PUT request.
   *
   * If client is not authenticated or access token has expired, a new authentication is automatically
   * performed.
   *
   * @async
   * @method put
   * @param {String} endPoint The web service end point to reach with query parameters
   * @param {Object|String} [body] The request body
   * @param {Object} [options] The list of http(s) options as described by NodeJS http.request documentation
   * @param {Number} [timeout=10000] Maximum execution time for the request (in ms), set it to Infinity for a request
   * without limits
   * @param {Boolean} [multiparted=false] true to send body as multipart/form-data
   * @return {Promise} Promise resolving with results as an Object
   * @throws {TypeError} Thrown if endPoint is not valid a String
   */
  put(endPoint, body, options, timeout, multiparted) {
    return this.executeRequest(&#x27;put&#x27;, endPoint, options, body, timeout, multiparted);
  }

  /**
   * Executes a DELETE request.
   *
   * If client is not authenticated or access token has expired, a new authentication is automatically
   * performed.
   *
   * @async
   * @method delete
   * @param {String} endPoint The web service end point to reach with query parameters
   * @param {Object} [options] The list of http(s) options as described by NodeJS http.request documentation
   * @param {Number} [timeout=10000] Maximum execution time for the request (in ms), set it to Infinity for a request
   * without limits
   * @return {Promise} Promise resolving with results as an Object
   * @throws {TypeError} Thrown if endPoint is not valid a String
   */
  delete(endPoint, options, timeout) {
    return this.executeRequest(&#x27;delete&#x27;, endPoint, options, null, timeout);
  }

  /**
   * Executes a REST request after making sure the client is authenticated.
   *
   * If client is not authenticated or access token has expired, a new authentication is automatically
   * performed and request is retried.
   *
   * @method executeRequest
   * @async
   * @private
   * @param {String} method The HTTP method to use (either get, post, delete or put)
   * @param {String} endPoint The web service end point to reach with query parameters
   * @param {Object} [options] The list of http(s) options as described by NodeJS http.request documentation
   * @param {Object|String} [body] The request body
   * @param {Number} [timeout=10000] Maximum execution time for the request (in ms), set it to Infinity for a request
   * without limits
   * @param {Boolean} [multiparted=false] true to send body as multipart/form-data
   * @return {Promise} Promise resolving with request&#x27;s response
   * @throws {TypeError} Thrown if method or endPoint is not a valid String
   */
  executeRequest(method, endPoint, options, body, timeout, multiparted) {
    return new Promise((resolve, reject) =&gt; {
      endPoint = &#x60;${this.path}/${endPoint}&#x60;.replace(/^\/+/, &#x27;&#x27;);
      options = options || {};

      // Merge options with default options
      options = Object.assign({
        path: &#x60;/${endPoint}&#x60;,
        method: method.toUpperCase(),
        headers: {}
      }, options);

      // Merge headers with default headers
      options.headers = Object.assign(
        {
          &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,
          Accept: &#x27;application/json&#x27;
        },
        options.headers
      );

      // Remove Content-Type header if multiparted, form-data will generate this header for us
      if (multiparted) delete options.headers[&#x27;Content-Type&#x27;];

      this.queuedRequests.add(this.buildRequest(options, body, timeout, multiparted, resolve, reject));
      this.authenticateAndExecute();
    });
  }

  /**
   * Indicates if the client is authenticated to the web service or not.
   *
   * @private
   * @method isAuthenticated
   * @return {Boolean} true if the client is authenticated, false otherwise
   */
  isAuthenticated() {
    return this.accessToken ? true : false;
  }

  /**
   * Gets the list of headers to send with each request.
   *
   * @private
   * @method getRequestHeaders
   * @return {Object} The list of headers to add to all requests sent to the server
   */
  getRequestHeaders() {
    return {};
  }

  /**
   * Authenticates the client to the web service.
   *
   * @private
   * @async
   * @method authenticate
   * @return {Promise} Promise resolving when the client is authenticated, promise is rejected if authentication
   * failed
   */
  authenticate() {
    return new Promise((resolve, reject) =&gt; {

      // Already authenticated
      if (this.isAuthenticated())
        resolve();
      else {

        // Not authenticated
        // Authenticate to the web service
        this.authenticateRequest.execute().then((result) =&gt; {
          if (result.error)
            reject(new AuthenticationError(result.error_description));
          else if (!result.access_token)
            reject(new AuthenticationError(&#x27;Invalid token&#x27;));
          else {
            this.accessToken = result.access_token;
            resolve();
          }
        }).catch((error) =&gt; {
          reject(error);
        });

      }

    });
  }

  /**
   * Authenticates client to the web service and execute all queued requests.
   */
  authenticateAndExecute() {

    /**
     * Interprets response results to get a human readable error message.
     *
     * @param {Object} result Web service response with an eventually error property and an httpCode property
     * @param {Request} request The request associated to the result
     * @return {String|Null} The error message
     */
    const getErrorMessage = (result, request) =&gt; {
      const options = request.options;

      if (result.error || result.httpCode &gt;= 400) {
        if (result.httpCode === 403)
          return &#x60;You don&#x27;t have the authorization to access the endpoint &quot;${options.method} ${options.path}&quot;&#x60;;
        else if (result.httpCode === 401)
          return &#x27;Authentication failed, verify your credentials&#x27;;
        else if (result.httpCode === 404)
          return &#x60;Resource ${options.path} not found&#x60;;
        else if (result.error) {
          const error = result.error;
          const message = error.message || &#x27;&#x27;;
          return &#x60;Error: &quot;${message}&quot; (code=${error.code}, module=${error.module})&#x60;;
        } else
          return &#x27;Unkown error&#x27;;
      }

      return null;
    };

    if (!this.authenticateRequest.isRunning) {

      // Authenticate to the web service
      this.authenticate().then(() =&gt; {

        // Client is now authenticated to the web service
        // Execute all queued requests
        this.queuedRequests.forEach((request) =&gt; {
          if (request.isRunning || this.authenticateRequest.isRunning) return;

          request.execute(this.getAuthenticationHeaders()).then((result) =&gt; {

            // Request done (meaning that transfer worked)

            if (result.error || result.httpCode &gt;= 400) {
              if (result.error_description &amp;&amp; (result.error_description === &#x27;Token not found or expired&#x27; ||
                                               result.error_description === &#x27;Token already expired&#x27;)) {

                // Token has expired, authenticate and try again
                // If still on error, after the maximum authentication attempts, reject the request

                this.accessToken = null;

                // Max attempts reached for this request, reject
                if (request.attempts &gt;= this.maxAuthenticationAttempts) {
                  this.queuedRequests.delete(request);
                  request.reject(new RequestError(&#x27;Max attempts reached&#x27;, result.httpCode));
                } else {
                  request.attempts++;
                  this.authenticateAndExecute();
                }

              } else {

                // An error has been returned by the web service
                // Reject the request with the error
                this.queuedRequests.delete(request);
                request.reject(new RequestError(getErrorMessage(result, request), result.httpCode));

              }
            } else {

              // Everything went fine
              // Resolve with the results
              this.queuedRequests.delete(request);
              request.resolve(result);

            }
          }).catch((error) =&gt; {

            // Request failed
            // Reject the request
            this.queuedRequests.delete(request);
            request.reject(error);

          });
        });
      }).catch((error) =&gt; {

        // Authentication failed
        // Reject and abort all queued requests with the same error and clear the queue
        rejectAll(this.queuedRequests, error);
        this.queuedRequests.clear();

      });
    }
  }

  /**
   * Builds a request.
   *
   * @private
   * @method buildRequest
   * @param {Object} [options] The list of http(s) options as described by NodeJS http.request documentation
   * @param {Object|String} [body] The request body
   * @param {Number} [timeout=10000] Maximum execution time for the request (in ms), set it to Infinity for a request
   * without limits
   * @param {Boolean} [multiparted=false] true to send body as multipart/form-data
   * @param {Function} resolve The function to call with request&#x27;s result
   * @param {Function} reject The function to call if request fails
   * @return {Request} The request, ready to be executed
   */
  buildRequest(options, body, timeout, multiparted, resolve, reject) {
    options = Object.assign({
      hostname: this.hostname,
      port: this.port
    }, options);

    // Add web service certificate as a trusted certificate
    if (this.certificate &amp;&amp; this.protocol === &#x27;https&#x27;) {

      /* eslint no-sync: 0 */
      options = Object.assign({
        ca: fs.readFileSync(path.normalize(this.certificate))
      }, options);

    }

    const request = new Request(this.protocol, options, body, timeout, multiparted);
    request.resolve = resolve;
    request.reject = reject;
    return request;
  }

  /**
   * Gets the list of headers to send with each request.
   *
   * @method getAuthenticationHeaders
   * @return {Object} The list of headers to add to all requests sent to the server
   */
  getAuthenticationHeaders() {
    return {};
  }

}

module.exports = RestClient;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
